## Contents
1. [Установка ОС](#part-1-установка-ос)  
2. [Создание пользователя](#part-2-создание-пользователя)  
3. [Настройка сети ОС](#part-3-настройка-сети-ос)   
4. [Обновление ОС](#part-4-обновление-ос)  
5. [Использование команды  sudo](#part-5-использование-команды-sudo)  
6. [Установка и настройка службы времени](#part-6-установка-и-настройка-службы-времени)  
7. [Установка и использование текстовых редакторов](#part-7-установка-и-использование-текстовых-редакторов)  
8. [Установка и базовая настройка сервиса SSHD](#part-8-установка-и-базовая-настройка-сервиса-sshd)   
9. [Установка и использование утилит top, htop](#part-9-установка-и-использование-утилит-top-htop)   
10. [Использование утилиты fdisk](#part-10-использование-утилиты-fdisk)   
11. [Использование утилиты df](#part-11-использование-утилиты-df)    
12. [Использование утилиты du](#part-12-использование-утилиты-du)    
13. [Установка и использование утилиты ncdu](#part-13-установка-и-использование-утилиты-ncdu)    
14. [Работа с системными журналами](#part-14-работа-с-системными-журналами)     
15. [Использование планировщика заданий CRON](#part-15-использование-планировщика-заданий-cron)    


## Part 1. Установка ОС

*	**Вывод версии Ubuntu**

При помощи команды ``cat /etc/issue`` получаем версию системы

![Вывод версии Ubuntu](img/1_1.png)


## Part 2. Создание пользователя

*	**Создание нового пользователя**

При помощи команды ``sudo adduser username`` создаем нового пользователя и добавляем его в группу **adm** командой ``usermod -a -G adm username``

![Новый пользователь](img/2_1.png)

*	**Отображение нового пользователя**

Командой ``grep -e adm /etc/gropup`` выводим список пользователей, находящихся в группе **adm**

![Список аккаунтов](img/2_2.png)


## Part 3. Настройка сети ОС

* **Задать название машины вида user-1**

При помощи команды ``sudo vim /etc/hostname`` изменяем в редакторе vim hostname на **user-1**

* **Установить временную зону, соответствующую вашему текущему местоположению**

Командой ``sudo timedatectl set-timezone Europe/Moscow`` меняем временную зону на соответствующую

![timedatectl](img/3_12.png)

* **Вывести названия сетевых интерфейсов с помощью консольной команды**

Выполнив команду ``sudo apt install net-tools``, установим утилиту для работы с сетевым окружением.

Команда ``ifconfig`` выведет список сетевых интерфейсов

![Сетевые интерфейсы](img/3_1.png)

Виртуальный сетевой интерфейс **loopback** используется для связи компьютера с самим собой. В основном используется для диагностики и устранения неполадок, а также для подключения к серверам, работающим на локальном компьютере. Если сетевой интерфейс отключен — например, когда порт Ethernet отключен, связь через этот интерфейс невозможна, даже связь между вашим компьютером и самим собой. Интерфейс loopback не представляет никакого реального оборудования, но существует, поэтому приложения, работающие на компьютере, всегда могут подключаться к серверам на той же машине. Это важно для устранения неполадок. Его иногда называют диагностическим инструментом.

* **Используя консольную команду получить ip адрес устройства, на котором вы работаете, от DHCP сервера**

Вводим команду ``ip address`` и получаем информацию о том, что ip устройства **10.0.2.15**

![ip устройства](img/3_2.png)

Также ip адрес можно увидеть в журнале DHCP, выполнив команду ``cat /var/lib/dhcp/dhclient.leases``

![DHCP журнал](img/3_3.png)

DHCP (Dynamic Host Configuration Protocol) — протокол прикладного уровня модели TCP/IP, служит для назначения IP-адреса клиенту. IP-адрес можно назначать вручную каждому клиенту в локальной сети, но в больших сетях это очень трудозатратно, к тому же, чем больше локальная сеть, тем выше возрастает вероятность ошибки при настройке. Поэтому для автоматизации назначения IP был создан протокол DHCP. 

* **Определить и вывести на экран внешний ip-адрес шлюза (ip) и внутренний IP-адрес шлюза, он же ip-адрес по умолчанию (gw)**

Внутренний ip **10.0.2.2** получаем командой ``route -n``.

![Внутренний ip](img/3_4.png)

Внешний ip можно получить с помощью утилиты **wget**, например командой ``wget -q -O - ifconfig.me/ip``

![Внешний ip](img/3_5.png)

* **Задать статичные (заданные вручную, а не полученные от DHCP сервера) настройки ip, gw, dns (использовать публичный DNS серверы, например 1.1.1.1 или 8.8.8.8)**

Для этого будем редактировать файл ``00-installer-config.yaml``. Открываем его командой ``sudo nano /etc/netplan/00-installer-config.yaml``

![00-installer-config.yaml](img/3_6.png)

По умолчанию интерфейс «enp0s3» получает IP-адрес от DHCP-сервера. 

![enp0s3 default](img/3_7.png)

Изменяем настройки на статические, после чего содержимое документа выглядит так:

![enp0s3 user set](img/3_8.png)

Командами ``sudo netplan apply`` и  ``sudo netplan try`` применяем изменения.

![enp0s3 user set apply](img/3_9.png)

* **Перезагрузить виртуальную машину. Убедиться, что статичные сетевые настройки (ip, gw, dns) соответствуют заданным в предыдущем пункте**

После перезагрузки файл ``00-installer-config.yaml`` сохранил статические настройки.

* **Пропинговать удаленные хосты 1.1.1.1 и ya.ru**

Пингуем хосты после ребута

![ya.ru](img/3_10.png)

![1.1.1.1](img/3_11.png)


## Part 4. Обновление ОС

* **Обновить системные пакеты до последней на момент выполнения задания версии**

Нужно по порядку ввести команды:

``sudo apt-get update``

``sudo apt-get upgrade``

``sudo apt-get dist-upgrade`` (выполяет «умное» разрешения конфликтов версий пакетов)

При повторном вводе команды в терминале будет сообщение, что обновления отсутствуют

![Обновлено](img/4_1.png)


## Part 5. Использование команды sudo

* Разрешить пользователю, созданному в Part 2, выполнять команду sudo

Использование sudo позволяет выполнять привилегированные команды обычным пользователям без необходимости ввода пароля суперпользователя root.
Добавляем созданного пользователя в группу sudo, чтобы тот мог выполнять команду sudo.
Для этого выполняем команду ``sudo usermod -aG sudo newuser``

![user to sudo](img/5_1.png)

* Поменять hostname ОС от имени пользователя, созданного в пункте Part 2 (используя sudo).

Чтобы поменять пользователя, нужно выполнить команду ``su newuser``

![switch user](img/5_2.png)

Меняем hostname от имени пользователя newuser на user-2

![rename hostname](img/5_3.png)

Проверяем изменение

![rename hostname](img/5_4.png)


## Part 6. Установка и настройка службы времени

* Вывести время часового пояса, в котором вы сейчас находитесь.

``timedatectl``

![real time](img/6_1.png)

Вывод следующей команды должен содержать ``NTPSynchronized=yes:`` 

``timedatectl show``

![timedatactl show](img/6_2.png)

Cлужба синхронизации времени активна


## Part 7. Установка и использование текстовых редакторов

* **Установить текстовые редакторы VIM (+ любые два по желанию NANO, MCEDIT, JOE и т.д.)**

* **Используя каждый из трех выбранных редакторов, создайте файл test_X.txt, где X -- название редактора, в котором создан файл. Напишите в нём свой никнейм, закройте файл с сохранением изменений**

Для создания файла и редактирование его через VIM пишем ``vim test_VIM.txt``.

Чтобы войти в режим редактирования, нажмем **i**. Чтобы сохранить изменения и выйти из редактора жмем сначала **esc**, затем **:wq**

![vim](img/7_1.png)

Вводим команду ``nano test_NANO.txt``, чтобы создать новый документ и редактировать его через редактор **nano**.

Пишем ник и выходим комбинацией **ctr+X**. Подтверждаем сохраниение **Y** и **Enter**.

![nano](img/7_2.png)

Устанавливаем редактор **joe** ``sudo apt install joe``.

Создаем новый файл ``joe test_joe.txt``.

Пишем ник и сохраняем файл зажав **ctr** и, последовательно нажав, **K** **X**

![joe](img/7_3.png)


* **Используя каждый из трех выбранных редакторов, откройте файл на редактирование, отредактируйте файл, заменив никнейм на строку "21 School 21", закройте файл без сохранения изменений**

Для выхода без сохранения в **VIM** нужно выйти с помощью команды **:q!**

![vim](img/7_4.png)

Для выхода без сохранения в **nano** нужно после **ctr+X** нажать **N**.

![nano](img/7_5.png)

Для выхода без сохранения в **joe** нужно после **ctr+C** нажать **Y**.

![joe](img/7_6.png)


* **Используя каждый из трех выбранных редакторов, отредактируйте файл ещё раз (по аналогии с предыдущим пунктом), а затем освойте функции поиска по содержимому файла (слово) и замены слова на любое другое**

Поиск слова в файле в **VIM** производится через ``/text``.

![vim](img/7_7.png)

Поиск и замена шаблона в файле в **VIM** производится командой ``:%s/{patter}/{text}/g``

![vim](img/7_8.png)

![vim](img/7_9.png)


Поиск слова в файле в **nano** производится через **ctr+W**.

![nano](img/7_10.png)

Посик слова/слов производится командой ``ctr+\``

Вводим сначала искомое слово, затем слово для замены и в конце жмем **A**, чтобы изменить все слова на шаблон

![nano](img/7_11.png)

![nano](img/7_12.png)

Чтобы найти слово в **joe** нужно поставить курсор в начало файла, нажать **ctr+K F**. Будет запрошен образец поиска. После нажатия Enter получим запрос на ввод опций поиска. Нажать Enter еще, чтобы редактор сразу начал поиск.

![joe](img/7_13.png)

После указания слова для поиска, можно ввести команду **r**, потом указать шаблон и дальше выбрать **r** для замены по всему тексту

![joe](img/7_14.png)

![joe](img/7_15.png)

![joe](img/7_16.png)


## Part 8. Установка и базовая настройка сервиса SSHD

*	**Установить службу SSHd**

Устанавливаем службу командой ``sudo apt-get install openssh-server``

![SSHd](img/8_1.png)


*	**Добавить автостарт службы при загрузке системы**

Добавляем службу в автостарт ``sudo systemctl enable ssh``

![SSHd start](img/8_2.png)

Проверим статус службы, выполнив команду ``sudo systemctl status ssh``

![SSHd status](img/8_6.png)

*	**Перенастроить службу SSHd на порт 2022**

Открываем файл конфигурации ``sudo vim /etc/ssh/sshd_config`` и меняем порт с 22 на 2022. Сохраняем, выходим, перегружаем систему.

![SSHd port 2022](img/8_3.png)


*	**Используя команду ``ps``, показать наличие процесса sshd. Для этого к команде нужно подобрать ключи**

Используем команду ``ps -FC sshd``, чтобы увидеь процесс

![SSHd process](img/8_4.png)

Утилита ``ps`` выводит состояние процессов на экран

  * -F показывает максимально доступные данные процессов
  * -С выбирает процессы по имени команды
  * UID - польтзователь, запустивший процесс
  * PID - инденфикатор процесса
  * PPID - индентификатор родительского процесса
  * C - процент времени CPU, используемое процессом
  * SZ - занимаемое место процесса в памяти
  * RSS - реальный размер процесса в памяти
  * PSR - ядро процессора, на котором выполняется процесс
  * STIME - время запуска процесса
  * TTY - терминал, из которого запущен процесс
  * TIME - общее время процессора, затраченного на выполнение процесса
  * CMD - команда запуска процесса

Проверяем вывод команды ``netstat -tan``

![SSHd process 2022 port](img/8_5.png)

Утилита **netstat** используется для того, чтобы посмотреть работает та или иная сетевая программа, открыты или закрыты порты или просто посмотреть маршрутизацию.

- 0.0.0.0 говорит о том, что к сети нет подключений в данный момент.
- Флаги:
  - -t - подключение по протоколу TCP;
  - -a - отображает подключения;
  - -n - отобразит сетевые адреса в виде чисел.
- Вывод:
  - Proto - протокол, используемый сокетом;
  - Recv-Q - число байтов, не переданных клиентом;
  - Send-Q - число байтов, не подтвержденных удаленным хостом;
  - Local Address - локальный адрес и номер порта локальной сети;
  - Foreign Address - локальный адрес и номер порта удаленной сети;
  - State - состояние сокета.


## Part 9. Установка и использование утилит top, htop

* **Установить и запустить утилиты top и htop.**

* **Утилита ``top``**

![top](img/9_1.png)

  *	uptime - ``up 1 min``;
  *	количество авторизованных пользователей - ``1 user``;
  *	общая загрузка системы. Указано 3 параметра - за 1 мин, 5 мин, 15 мин соответствнно. Все 0.00;
  * общее количество процессов -  ``Tasks 102 total``.  Их классифицируют на работающие, спящие, остановленные и зомби (выключенные и не очищенные);
  * загрузка cpu ``%Cpu(s):`` система простаивает, поэтому около нуля;
  * загрузка памяти ``MiB Mem :`` - загрузка оперативной памяти - 3924.3. ``MiB Swap:`` - загрузка файла подкачки - 0;
  * PID процесса, занимающего больше всего памяти. Комбинацией ``shift+M`` сортируем таблицу по занимаемой памяти. Это процесс с PID 408

	![max Mem](img/9_2.png)
  * PID процесса, занимающего больше всего процессорного времени. Изначально таблица отсортирована так, что сортирует процессы по процессорному времени.

	![max Time](img/9_3.png)

  * **Утилита ``htop``**

![htop](img/9_4.png)

  * Чтобы отсортировать, жмем ``F6`` и выбираем параметр сортировки
		
	PID

    ![htop](img/9_5.png)	
			
	PERCENT_CPU

     ![htop](img/9_6.png)

	PERCENT_MEM

    ![htop](img/9_7.png)

	TIME

     ![htop](img/9_8.png)

  *	отфильтрованному для процесса sshd. Жмем ``F4`` и вводим sshd;

	![htop](img/9_9.png)

  *	с процессом syslog, найденным, используя поиск. Жмем ``F3`` и вводим syslog;

	![htop](img/9_10.png)

  *	с добавленным выводом hostname, clock и uptime.  Жмем ``F2`` и в правой колонке выбираем нужные параметры, после чего жмем ``F10``

	![htop](img/9_11.png)


## Part 10. Использование утилиты fdisk

* **Выполняем команду ``sudo fdisk -l``**

![fdisk](img/10_1.png)

  - название жесткого диска ``/dev/sda``;
  - размер жесткого диска ``10 GIB``;
  - количество секторов ``20971520``;
  - размер swap. По результатам работы утилиты ``top`` было видно, что swap равен 0.


## Part 11. Использование утилиты df

*	**Запускаем команду ``df``**

![df](img/11_1.png)

  - размер раздела ``8408452 kB``
  - размер занятого пространства ``2719320 kB``
  - размер свободного пространства ``5240416 kB``
  - процент использования ``35%``
  - 1K-blocks = 1 kB

* **Выполняем команду ``df -Th``**

![df -Th](img/11_2.png)

  - размер раздела ``8.1 G``
  - размер занятого пространства ``2.6 G``
  - размер свободного пространства ``5.0 G``
  - процент использования ``35%``
  - тип файловой системы раздела ``ext4``


## Part 12. Использование утилиты du

* **Запустить команду ``du``**

![du](img/12_1.png)

* **Вывести размер папок /home, /var, /var/log (в байтах, в человекочитаемом виде)**

Выполним команду ``sudo du -hs /home /var/log /var``
  * Флаг -h выводит информацию в человекочитаемом виде
  * Флаг -s выводит только корневую папку с общим размером всех вложенных файлов и папок

![du -sh](img/12_2.png)

* **Вывести размер всего содержимого в /var/log (не общее, а каждого вложенного элемента, используя** ***)**

Выполним команду ``sudo du -h /var/log*``

![du -h /var/log*](img/12_3.png)


## Part 13. Установка и использование утилиты ncdu

* **Установить утилиту ncdu**

Выполняем команду ``sudo apt install ncdu``

* **Вывести размер папок /home, /var, /var/log**

Выполняем команду ``ncdu /`` и проходимся по нужным разделам, чтобы получить информацию о размерах разделов

![ncdu](img/13_1.png)

  * /home 96 KiB

	![ncdu](img/13_2.png)

  * /var 493.7 MiB

	![ncdu](img/13_3.png)

  * /var/log 215.6 MiB

	![ncdu](img/13_4.png)


## Part 14. Работа с системными журналами

* **Открываем системные журналы**

Будем делать это при помощи утилиты ``tail``, которая по умолчанию показывает последний 10 строк файла

  * ``tail /var/log/dmesg``

	![dmesg](img/14_1.png)

  * ``tail /var/log/syslog``

	![syslog](img/14_2.png)

  * ``tail /var/log/auth.log``

	![auth.log](img/14_3.png)

Строчка в журнале ``auth.log`` с последней успешной авторизацией

![auth.log](img/14_4.png)

Перезапускаем службу **SSHd** командой ``sudo systemctl restart ssh.service``. В журнале syslog видим информацию об успешном рестарте службы

![syslog](img/14_5.png)


## Part 15. Использование планировщика заданий CRON

* **Используя планировщик заданий, запустите команду uptime через каждые 2 минуты**

Выполняем команду ``crontab -e`` и выбираем редактор. Внизу файла вводим команду ``*/2 * * * * uptime``

![crontab -e](img/15_1.png)

Убедимся, что каждые 2 минуты планировщик вызывает uptime, войдя в системный журнал

![syslog](img/15_2.png)

Теперь удалим задачи планировщика и выведем их список, поочередно выполнив команды

  * ``crontab -r``
  * ``crontab -l``

![crontab -r](img/15_3.png)

